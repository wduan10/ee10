MODULE      ProgramAccess
INTERFACE  (Offset7..Offset0, Direct12..Direct0,
            AbsoluteAddr, RelativeAddr, StackLower, StackUpper, Step,
            Reset, Clock
            -> ProgAddr12..ProgAddr0, PC12..PC0);

TITLE      'Program Address Unit'


" Description:  This module implements the Program Memory Access Unit of the CPU.
"               It is responsible for generating the program memory address used
"               to fetch the next instruction.  The unit maintains the Program
"               Counter (PC), updates it on each clock cycle, and selects the
"               next PC value based on control signals. Control signals use one
"               hot encoding.
"
"               Depending on the active control inputs, the Program Counter may
"               be incremented, loaded with a direct address, updated using
"               a signed offset for program-relative addressing, or replaced
"               with a stack address.  The module outputs both the current
"               Program Counter value and the computed program address bus.
"
" Inputs:       Offset[7..0]     - 8 bits of data or offset input
"               Direct[12..0]    - 13 bits of address or data input
"               AbsoluteAddr     - control input for absolute address
"               RelativeAddr     - control input for relative address
"               StackLower       - control input for updating lower 8 bits of
"                                  the address with the lower 8 bits of the
"                                  stack address, provided as Offset[7..0]
"               StackUpper       - control input for updating upper 5 bits of
"                                  the address with the upper 5 bits of the
"                                  stack address, provided as Offset[4..0]
"               Step             - control input for incrementing program counter
"                                  by 1
"               Reset            - system reset
"               Clock            - system clock
"
" Outputs:      ProgAddr[12..0]  - 13 bits of program address bus
"               PC[12..0]        - 13 bits of program counter


" Revision History:
" 02/19/26   Wilson Duan  Initial Revision
" 02/19/26   Wilson Duan  Fix bug by defining intermediate terms



" Pin/Signal Declarations

" Inputs

Offset7..Offset0    pin;        "input  8 bits of data or offset input
Direct12..Direct0   pin;        "input  13 bits of address or data input

" Control Inputs
AbsoluteAddr        pin;        "input  control input for absolute address
RelativeAddr        pin;        "input  control input for relative address
StackLower          pin;        "input  control input for updating lower 8 bits of
                                "       the address with the lower 8 bits of the
                                "       stack address, provided as Offset[7..0]
StackUpper          pin;        "input  control input for updating upper 5 bits of
                                "       the address with the upper 5 bits of the
                                "       stack address, provided as Offset[4..0]
Step                pin;        "input  control input for incrementing program counter

Reset			    pin;	    "input  system reset
Clock           	pin;	    "input  system clock


" Outputs

ProgAddr12..ProgAddr0   pin;                "output  13 bits of program address bus
PC12..PC0               pin ISTYPE 'REG';   "output  13 bits of program counter


" Intermediate Terms
relative                                    node;   "equals 1 when doing relative PC operations
                                                    "this term is combined with PC in an AND gate
                                                    "before the adder
SignExtendedOffset13..SignExtendedOffset0   node;   "sign extend offset from 8 bits to 13 bits
StackLower13..StackLower0                   node;   "pad offset with zeros to get 13 bit representation
                                                    "of lower part of stack address
StackUpper13..StackUpper0                   node;   "pad offset with zeros to get 13 bit representation
                                                    "of upper part of stack address
Carry13..Carry0                             node;   "14 bits of carry to perform addition
                                                    "note that CarryIn[i] = CarryOut[i-1]
MuxOut12..MuxOut0                           node;   "13 bits of output of mux from lecture slides
                                                    "this MuxOut is fed into the adder

" Buses

Offset              =  [Offset7..Offset0];		"8 bits of data or offset
Direct              =  [Direct12..Direct0];		"13 bits of address or data
ProgAddr            =  [ProgAddr12..ProgAddr0];	"13 bits of program address bus
PC                  =  [PC12..PC0];              "13 bits of program counter
SignExtendedOffset  =  [SignExtendedOffset13..SignExtendedOffset0] "13 bits of sign extended offset
StackLower          =  [StackLower13..StackLower0]                 "13 bits containing padded lower stack address"
StackUpper          =  [StackUpper13..StackUpper0]                 "13 bits containing padded upper stack address"
Carry               =  [Carry13..Carry0];        "14 bits of carry to perform addition
MuxOut              =  [MuxOut12..MuxOut0];      "13 bits of output of mux from lecture slides
                                        "this MuxOut is fed into the adder


" Constants

ONE   =  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 ];    " 13-bit value of 1



EQUATIONS

" clock for the program counter output
PC.CLK = Clock;

" sign extend the offset to preserve its sign during addition
SignExtendedOffset = [Offset7, Offset7, Offset7, Offset7, Offset7, Offset7..Offset0];
" pad the offset with zeros as appropriate for stack variables
StackLowerOffset = [0, 0, 0, 0, 0, Offset7..Offset0];
StackUpperOffset = [Offset4..Offset0, 0, 0, 0, 0, 0, 0, 0, 0];

relative = RelativeAddr # Step;
MuxOut = (Direct & AbsoluteAddr) #
         (SignExtendedOffset & RelativeAddr) #
         (StackLowerOffset & StackLower) #
         (StackUpperOffset & StackUpper) #
         (ONE & Step) #
         (0 & Reset);

" since the equations are calculated simultaneously, we put both CarryIn and CarryOut
" into the same Carry array and calculate both together
Carry0 = 0; " the CarryIn for the lowest order bit is zero
[Carry13..Carry1] = ((PC & relative) & MuxOut) # ([Carry12..Carry0] & ((PC & relative) $ MuxOut));
PC = (PC & relative) $ MuxOut $ Carry;


END  ProgramAccess