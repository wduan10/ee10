Module      StatusRegister
INTERFACE  (MuxOut7..MuxOut0,
            DataIn7..DataIn0,
            CarryOutMSB, CarryInMSB,
            ShiftRotateCarryOut,

            Subtract,
            ArithmeticOperation, FunctionOperation, ShiftRotateOperation,
            Clock, Reset, Hold, Pop
            -> Flags7..Flags0);

TITLE       'StatusRegister for Flag Updates'


" Description:  This module computes and updates the ALU status flags given
"               the accumulator output, adder block output, and shift block output.
"               The SignFlag and ZeroFlag are affected by every operation, so they are
"               always computed. On the other hand, CarryFlag and OverflowFlag are affected
"               only by Arithmetic operations or Shift/Rotate operations, so the equations
"               reflect this (via a mux).
" Inputs:       MuxOut[7..0]             - 8-bit mux output from accumulator block
"               DataIn[7..0]             - 8-bit input for popping
"               CarryOutMSB              - carry out of the MSB from the adder
"               CarryInMSB               - carry into the MSB from the adder
"               ShiftRotateCarryOut      - bit shifted out during shift/rotate
"
"               Subtract                 - active high when operation is subtraction-type
"               ArithmeticOperation      - active high when current op is arithmeti
"               FunctionOperation        - active high when current op is logical/function
"               ShiftRotateOperation     - active high when current op is shift/rotate
"               Clock                    - system clock
"               Reset                    - system reset
"               Hold                     - active high when we should hold
"               Pop                      - control input for pop
"
" Outputs:      Flags7..Flags0           - output flags


" Revision History:
" 02/26/26   Wilson Duan  Initial revision
" 02/27/26   Wilson Duan  Pass MuxOut into status register instead of Accum



" Pin/Signal Declarations

" Inputs
MuxOut7..MuxOut0        pin;  "input  8-bit mux output from accumulator block
DataIn7..DataIn0        pin;  "input  8-bit data to pop onto flags
CarryOutMSB             pin;    "input  carry out of MSB from adder
CarryInMSB              pin;    "input  carry into MSB from adder
ShiftRotateCarryOut     pin;    "input  bit shifted out during shift/rotate

Subtract                pin;    "input  if op is subtraction-type (CMP/DEC/SBB/SUB)
ArithmeticOperation     pin;    "input  if op is arithmetic
FunctionOperation       pin;    "input  if op is logic/function
ShiftRotateOperation    pin;    "input  if op is shift/rotate

Reset	pin;	"input  system reset
Clock   pin;	"input  system clock
Hold    pin;    "input  if we should hold
Pop     pin;    "input  control input for pop

" Outputs
Flags7..Flags0          pin ISTYPE 'REG';    "output  flags

" Intermediate nodes
SignFlag                node;    "output  sign flag
OverflowFlag            node;    "output  overflow flag for signed arithmetic
CarryFlag               node;    "output  carry/borrow or shift carry
ZeroFlag                node;    "output  zero flag

" Buses
Flags = [Flags7..Flags0];
DataIn = [DataIn7..DataIn0];


EQUATIONS

" set clocks and reset
Flags.CLK = Clock;
Flags.CLR = Reset;

" compute sign and zero flags
" these are affected by all operations except hold
SignFlag = (MuxOut7 & !Hold) # (SignFlag & Hold);
ZeroFlag = (!(MuxOut7 # MuxOut6 # MuxOut5 # MuxOut4 #
              MuxOut3 # MuxOut2 # MuxOut1 # MuxOut0) & !Hold) #
            (ZeroFlag & Hold);

" compute carry and overflow flags
" these are modified by arithmetic or shifts, but not functional operations
CarryFlag = ((CarryOutMSB $ Subtract) & ArithmeticOperation) #
             (ShiftRotateCarryOut & ShiftRotateOperation) #
             (CarryFlag & (FunctionOperation # Hold));

" ShiftRotateOverflow = LSL & (MuxOut7 $ ShiftRotateCarryOut);
" ask TA about overflow for left shifts
OverflowFlag = ((CarryOutMSB $ CarryInMSB) & ArithmeticOperation) #
                (0 & ShiftRotateOperation) #
                (OverflowFlag & (FunctionOperation # Hold));

Flags := (DataIn & Pop) # ([0, 0, 0, 0, CarryFlag, OverflowFlag, SignFlag, ZeroFlag] & !Pop);

End         StatusRegister